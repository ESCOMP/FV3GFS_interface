#!/usr/bin/env python

"""FV3GFS namelist creator
"""

# Typically ignore this.
# pylint: disable=invalid-name

# Disable these because this is our standard setup
# pylint: disable=wildcard-import,unused-wildcard-import,wrong-import-position

import os, shutil, sys, glob, stat, filecmp, imp, re

CIMEROOT = os.environ.get("CIMEROOT")
if CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")
sys.path.append(os.path.join(CIMEROOT, "scripts", "Tools"))

from standard_script_setup import *
from CIME.case import Case
from CIME.nmlgen import NamelistGenerator
from CIME.utils import expect, get_model
from CIME.buildnml import create_namelist_infile, parse_input
from CIME.utils import run_cmd

logger = logging.getLogger(__name__)

# find factors of a number
def factors(n):
    return set(x for tup in ([i, n//i] for i in range(1, int(n**0.5)+1) if n % i == 0) for x in tup)

# check if all elements in a list are same
def checkList(lst): 
    ele = lst[0] 
    chk = True
    # Comparing each element with first item  
    for item in lst: 
        if ele != item: 
            chk = False
            break; 
    return chk 

# prepares the input files of a case and places in rundir:
def prep_input(case):
    casename        = case.get_value("CASE")
    Buildconf       = case.get_value("CASEBUILD")
    rundir          = case.get_value("RUNDIR")
    atm_grid        = case.get_value("ATM_GRID")
    testcase        = case.get_value("TEST")
    model           = get_model()

# This section below is how input files 
# are copied in NEMS and is just for reference
#
#     # Specify input files.
#     filters input {
#       #    WORK FILE           <=filter=     SOURCE FILE
#           'input.nml'          <=atparse=  " @[PARMnems]/input.mom6.nml.IN"
#     'model_configure'          <=atparse=  " @[PARMnems]/model_configure.IN"
#         'aerosol.dat'          <=copyfrom= " @[FV3_input_data]/INPUT"
#   'co2historicaldata_201*.txt' <=copyfrom= " @[FV3_input_data]/INPUT"
#   'global_o3prdlos.f77'        <=copyfrom= " @[FV3_input_data]/INPUT"
#       'sfc_emissivity_idx.txt' <=copyfrom= " @[FV3_input_data]/INPUT"
#    'solarconstant_noaa_an.txt' <=copyfrom= " @[FV3_input_data]/INPUT"
#                '*grb'          <=copyfrom= " @[FV3_input_data]"
#             '*_table'          <=copyfrom= " @[FV3_input_data]"
#          '*configure'          <=copyfrom= " @[FV3_input_data]"
#               'INPUT'          <=copy=     " @[FV3_input_data]/INPUT"
# 'INPUT/C96_mosaic.nc'          <=copy=     " @[FV3_input_data]/INPUT/grid_spec.nc"
#      'nems.configure'          <=atparse=  " @[PARMnems]/nems.configure.@[nems_configure].IN"
#             'INPUT/*'          <=copyfrom= " @[UGCS_input_data]/MOM6_FIX_025deg"
#  'INPUT/MOM6_IC_TS.nc'         <=copy=    "  @[UGCS_input_data]/MOM6_IC/MOM6_IC_TS.nc"
#                   '*'          <=copyfrom= " @[UGCS_input_data]/CICE"
#                   '*'          <=copyfrom= " @[UGCS_input_data]/MEDIATOR_atm_flux"
#  'INPUT/grid_spec.nc'          <=copy=    "  @[UGCS_input_data]/COUPLED/grid_spec.nc"
#          'diag_table'          <=copy=    "  @[UGCS_input_data]/COUPLED/diag_table"
#     }

    # Determine fv3 inputdata directory (xml variable in env_mach_specific.xml)
    ugcs_input_dir = os.environ.get("UGCSINPUTPATH")
    expect((ugcs_input_dir is not None), "You must set the UGCSINPUTPATH to your input directory location.")

    # Determine fv3 fixed files directory (xml variable in env_mach_specific.xml)
    ugcs_fixed_file_dir = os.environ.get("UGCSFIXEDFILEPATH")
    expect((ugcs_fixed_file_dir is not None), "You must set the UGCSFIXEDFILEPATH to your fixed files directory location.")

    # Determine fv3 addtional files directory (xml variable in env_mach_specific.xml)
    ugcs_addon_dir = os.environ.get("UGCSADDONPATH")
    expect((ugcs_addon_dir is not None), "You must set the UGCSADDONPATH to your grid spec and diag_table files directory location.")

    # fv3 input directory
    fv3_input_dir = ugcs_input_dir

    # maps input file -> output file
    # if output file is "", then keep same name
    fv3_input_files = {
        "aerosol.dat" : "",
        "co2historicaldata_201*.txt" : "",
        "global_o3prdlos.f77" : "",
        "global_h2oprdlos.f77" : "",
        "sfc_emissivity_idx.txt" : "",
        "solarconstant_noaa_an.txt" : "",
        "*grb" : "",
        "*_table" : "",
        "*configure" : "",
        "INPUT/*" : "INPUT",
        "input.nml" : "",
        "diag_table" : "",
        "postxconfig-NT.txt" : "",
        "params_grib2_tbl_new" : "",
    }

    # additional files for run
    ugcs_input_files = {
        os.path.join(ugcs_addon_dir, atm_grid, "grid_spec.nc") : "INPUT/grid_spec.nc",
    }    
    #os.path.join(ugcs_addon_dir, atm_grid, "diag_table.cmeps") : "diag_table",
    
    # create symbolic links for these dirs
    input_dirs_to_link = []

    # resolution dependent parameters (need to manage fixed files)
    if (atm_grid == 'C96'):
        res_str = "t126.384.190"
        if (model == "ufs"):
           res_str = "t1534.3072.1536"
    elif (atm_grid == 'C384'):  
        res_str = "t766.1536.768"
    else:
        expect(False, "Given resolution " + atm_grid + " currently not supported!")

    # create symbolic links for these files
    input_files_to_link = {
        os.path.join(ugcs_fixed_file_dir, "global_glacier.2x2.grb") : "global_glacier.2x2.grb",
        os.path.join(ugcs_fixed_file_dir, "global_maxice.2x2.grb") : "global_maxice.2x2.grb",
        os.path.join(ugcs_fixed_file_dir, "RTGSST.1982.2012.monthly.clim.grb") : "RTGSST.1982.2012.monthly.clim.grb",
        os.path.join(ugcs_fixed_file_dir, "global_snoclim.1.875.grb") : "global_snoclim.1.875.grb",
        os.path.join(ugcs_fixed_file_dir, "global_snowfree_albedo.bosu." + res_str + ".rg.grb") : "global_snowfree_albedo.bosu." + res_str + ".rg.grb",
        os.path.join(ugcs_fixed_file_dir, "global_albedo4.1x1.grb") : "global_albedo4.1x1.grb",
        os.path.join(ugcs_fixed_file_dir, "CFSR.SEAICE.1982.2012.monthly.clim.grb") : "CFSR.SEAICE.1982.2012.monthly.clim.grb",
        os.path.join(ugcs_fixed_file_dir, "global_tg3clim.2.6x1.5.grb") : "global_tg3clim.2.6x1.5.grb",
        os.path.join(ugcs_fixed_file_dir, "global_vegfrac.0.144.decpercent.grb") : "global_vegfrac.0.144.decpercent.grb",
        os.path.join(ugcs_fixed_file_dir, "global_vegtype.igbp." + res_str + ".rg.grb") : "global_vegtype.igbp." + res_str + ".rg.grb",
        os.path.join(ugcs_fixed_file_dir, "global_soiltype.statsgo." + res_str + ".rg.grb") : "global_soiltype.statsgo." + res_str + ".rg.grb",
        os.path.join(ugcs_fixed_file_dir, "global_soilmgldas." + res_str + ".grb") : "global_soilmgldas." + res_str + ".grb",
        os.path.join(ugcs_fixed_file_dir, "seaice_newland.grb") : "seaice_newland.grb",
        os.path.join(ugcs_fixed_file_dir, "global_shdmin.0.144x0.144.grb") : "global_shdmin.0.144x0.144.grb",
        os.path.join(ugcs_fixed_file_dir, "global_shdmax.0.144x0.144.grb") : "global_shdmax.0.144x0.144.grb",
        os.path.join(ugcs_fixed_file_dir, "global_slope.1x1.grb") : "global_slope.1x1.grb",
        os.path.join(ugcs_fixed_file_dir, "global_zorclim.1x1.grb") : "global_zorclim.1x1.grb",
        os.path.join(ugcs_fixed_file_dir, "global_slmask." + res_str + ".grb") : "global_slmask." + res_str + ".grb",
        os.path.join(ugcs_fixed_file_dir, "global_mxsnoalb.uariz." + res_str + ".rg.grb") : "global_mxsnoalb.uariz." + res_str + ".rg.grb"
    }
    
    #if (atm_grid == 'C384'):
    #     input_files_to_link[os.path.join(ugcs_fixed_file_dir, "global_soilmgldas.statsgo." + res_str + ".grb")] = "global_soilmgldas.statsgo." + res_str + ".grb"
    input_files_to_link[os.path.join(ugcs_fixed_file_dir, "global_soilmgldas.statsgo." + res_str + ".grb")] = "global_soilmgldas.statsgo." + res_str + ".grb"

    # Make sure that rundir exists. If not, make it:
    if not os.path.exists(rundir):
        os.makedirs(rundir)

    # create INPUT and RESTART directories
    logger.info("\tCreating INPUT and RESTART directory")
    run_cmd("mkdir " + os.path.join(rundir, "INPUT"))
    run_cmd("mkdir " + os.path.join(rundir, "RESTART"))

    # copy template input files:
    logger.info("\tCopying input files")
    
    for input_file_name in fv3_input_files:
        input_file_path = os.path.join(fv3_input_dir, input_file_name)
        if "*" not in input_file_name and not os.path.exists(input_file_path):
            expect(False, "Couldn't find input file path: " + input_file_path)
        logger.info("cp " + input_file_path + " " + os.path.join(rundir, fv3_input_files[input_file_name]))
        run_cmd("cp " + input_file_path + " " + os.path.join(rundir, fv3_input_files[input_file_name]))

    for input_file_name in ugcs_input_files:
        input_file_path = os.path.join(ugcs_input_dir, input_file_name)
        if not os.path.exists(input_file_path):
            expect(False, "Couldn't find input file path: " + input_file_path)
        logger.info("cp " + input_file_path + " " + os.path.join(rundir, ugcs_input_files[input_file_name]))
        run_cmd("cp " + input_file_path + " " + os.path.join(rundir, ugcs_input_files[input_file_name]))

    logger.info("\tLinking input directories")
    for input_dir_name in input_dirs_to_link:
        input_dir_path = os.path.join(input_templates_dir, input_dir_name)
        if not os.path.exists(input_dir_path):
            expect(False, "Couldn't find input direcory " + input_dir_path)
        run_cmd("ln -s " + input_dir_path + " " + os.path.join(rundir, input_dir_name))

    logger.info("\tLinking input static input files")
    for input_file_name in input_files_to_link:
        if not os.path.isfile(input_file_name):
            expect(False, "Couldn't find file " + input_file_name)
        run_cmd("ln -s " + input_file_name + " " + os.path.join(rundir, input_files_to_link[input_file_name]))

    # do replacements in diag_table
    if os.path.exists(os.path.join(rundir, "diag_table")):
        with open(os.path.join(rundir,"diag_table"), 'r') as diag_table_in:
            with open(os.path.join(rundir,"diag_table.tmp"), 'w') as diag_table:
                for line in diag_table_in:
                    line = line.replace('CASENAME', casename)
                    # Use cesm style file names
                    line = line.replace("%4yr-%3dy", "%4yr-%2mo-%2dy-%5sc")
                    if testcase:
                        # this makes all real fields double precision
                        if line.endswith('2\n'):
                            line = line[:-2] + "1\n"
                            # this changes output frequency and number of records per file
                            # using HIST_N and HIST_OPTION from case
                            if line.startswith("\""+casename):
                                parts = line.split(',')
                                if len(parts) > 7:
                                    parts[1] = "1"
                                    parts[2] = "days"
                                    parts[6] = parts[1]
                                    parts[7] = parts[2]
                                    line = ','.join(parts)+"\n"
                    diag_table.writelines(line)
        os.rename(os.path.join(rundir,"diag_table.tmp"), os.path.join(rundir,"diag_table"))

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
####################################################################################
def _create_namelist_input(case, confdir, infile, nmlgen1, nmlgen2):
####################################################################################
    """Write out the namelist for this component.

    Most arguments are the same as those for `NamelistGenerator`.
    The `confdir` argument is used to specify the directory  in which output files will be placed.
    """
    #----------------------------------------------------
    # Clear out old data.
    #----------------------------------------------------
    data_list_path = os.path.join(case.get_case_root(), "Buildconf", "fv3gfs.input_data_list")

    #----------------------------------------------------
    # Create config dictionary
    #----------------------------------------------------
    config = {}

    #----------------------------------------------------
    # Initialize namelist defaults
    #----------------------------------------------------
    nmlgen2.init_defaults(infile, config)

    #----------------------------------------------------
    # Modify namelist defaults
    #----------------------------------------------------

    # modify layout namelist option to be consistent with given number of task
    atm_grid = case.get_value("ATM_GRID")
    ntask_atm = int(case.get_value('NTASKS_ATM'))
    ntask_write = int(nmlgen1.get_value('write_tasks_per_group'))
    n_write_groups = int(nmlgen1.get_value('write_groups'))
    ntiles = int(nmlgen2.get_value('ntiles'))

    if ((ntask_atm-ntask_write)%ntiles != 0):
        expect(False, "(ntask_atm-write_tasks_per_group*write_groups)%%ntiles must equal to 0! (%d-%d)/%d = %d" % 
             (ntask_atm,ntask_write,ntiles,(ntask_atm-(ntask_write*n_write_groups))%ntiles))
    else:
        # get default value
        layout = nmlgen2.get_value('layout')
        layout_x = int(layout[0])  
        layout_y = int(layout[1])  

        # check it
        if (((layout_x*layout_y)*ntiles+(ntask_write*n_write_groups)) != ntask_atm):
            logger.info("\tWARNING: (layout(1)*layout(2)*ntiles+write_tasks_per_group*write_groups) must equal to %d but it is %d!" %
                (ntask_atm,(layout_x*layout_y)*ntiles+(ntask_write*n_write_groups)))

            # calculate total number of task
            ntask = (ntask_atm-(ntask_write*n_write_groups))/ntiles
            # calculate dividers
            fact1 = sorted(list(factors(ntask)))
            fact2 = [ntask/i for i in fact1]
            # get differencies
            res = [abs(x1 - x2) for (x1, x2) in zip(fact1, fact2)]
            # check values
            for i in xrange(len(res)):
                if (atm_grid == 'C96'):
                    if (96%fact1[i] != 0 or 96%fact2[i] != 0):
                        res[i] = 999  
                elif (atm_grid == 'C384'):
                    if (384%fact1[i] != 0 or 384%fact2[i] != 0):
                        res[i] = 999  
                else:
                    expect(False, "Given resolution " + atm_grid + " currently not supported!")
            # check there is a suitable option for layout or not?
            if (checkList(res) and res[0] == 999):
                expect(False, "You must provide a resonable layout pair! The resolution (" + atm_grid[1:] + ") need to be divided evenly with layouts. To fix the issue, 1) the total number of PEs assigned to ATM component or 2) modify write_tasks_per_group (in user_nl_fv3gfs) can be modified.") 
            # find indices of smallest diff
            i = res.index(min(res))
            # set layout
            nmlgen2.set_value('layout', value=[fact1[i],fact2[i],])
            # print out new factors
            logger.info("\tusing automatically generated layout configuration %s x %s" % (fact1[i], fact2[i]))

    # modify file names based on selected resolution
    res_dict = {'384x190':'t126', '1536x768':'t766'}

    for var in nmlgen2.get_group_variables('namsfc'):
        var_str = str(nmlgen2.get_value(var))
        if re.search('.t[1-9][1-9]', var_str):
            lst = var_str.split(".")
            indx = [i for i, item in enumerate(lst) if re.search('t[1-9][1-9]', item)]
            key = "%sx%s" % (nmlgen1.get_value('imo'), nmlgen1.get_value('jmo'))
            lst[indx[0]] = res_dict[key]
            lst[indx[0]+1] = nmlgen1.get_value('imo') 
            lst[indx[0]+2] = nmlgen1.get_value('jmo') 
            var_str_out = ".".join(lst)
            nmlgen2.set_value(var, value=var_str_out)

    #----------------------------------------------------
    # Write out namelist groups
    #----------------------------------------------------

    # path for namelist files 
    srcroot = case.get_value("SRCROOT")
    namelist_xml_dir = os.path.join(srcroot, "src", "model", "FV3", "cime", "cime_config")

    # create list of groups by querying xml file
    groups = []
    with open(os.path.join(namelist_xml_dir, "namelist_definition_fv3.xml"), 'r') as fin:
        for s in fin.xreadlines():
            if "<group>" in s:
                groups.append(s.replace('<group>', '').replace('</group>', '').strip())

    # remove duplicates
    groups = list(set(groups))

    # keep only fv3gfs related ones
    groups.remove('config') # chgres
    groups.remove('_no_group_var') # model_configure
    groups.remove('freeform') # ncep_post
    groups.remove('nampgb') # ncep_post

    # sort group
    groups.sort()

    namelist_file = os.path.join(confdir, "atm_in")
    nmlgen2.write_output_file(namelist_file, data_list_path, groups=groups, sorted_groups=False)

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
####################################################################################
def _create_namelist_model_configure(case, confdir, infile, nmlgen):
####################################################################################
    """Write out the namelist for this component.

    Most arguments are the same as those for `NamelistGenerator`.
    The `confdir` argument is used to specify the directory  in which output files will be placed.
    """
    #----------------------------------------------------
    # Clear out old data.
    #----------------------------------------------------
    data_list_path = os.path.join(case.get_case_root(), "Buildconf", "fv3gfs.input_data_list")
    if os.path.exists(data_list_path):
        os.remove(data_list_path)

    #----------------------------------------------------
    # Create config dictionary
    #----------------------------------------------------
    config = {}

    #----------------------------------------------------
    # Initialize namelist defaults
    #----------------------------------------------------
    nmlgen.init_defaults(infile, config)

    #----------------------------------------------------
    # Modify namelist defaults
    #----------------------------------------------------

    # modify start date
    run_start_date = case.get_value('RUN_STARTDATE').split('-')
    yyyy = int(run_start_date[0])
    mm = int(run_start_date[1])
    dd = int(run_start_date[2])
    nmlgen.set_value('start_year', value=yyyy)
    nmlgen.set_value('start_month', value=mm)
    nmlgen.set_value('start_day', value=dd)

    run_start_tod = case.get_value('START_TOD')
    hh = int(run_start_tod//3600)
    mi = int((run_start_tod-hh*3600)//60)
    ss = int(run_start_tod-hh*3600-mi*60)
    nmlgen.set_value('start_hour', value=hh)
    nmlgen.set_value('start_minute', value=mi)
    nmlgen.set_value('start_second', value=ss)

    # TODO: modify forecast lenght ? need to use dateutil.relativedelta.relativedelta to simplify the code
    #cal_option = case.get_value('CALENDAR')
    #stop_option = case.get_value('STOP_OPTION')
    #stop_n = int(case.get_value('STOP_N'))
    #if 'nyear' in stop_option:
    #    if cal_option == 'NO_LEAP':
    #        nmlgen.set_value('nhours_fcst', value=stop_n*365*24)
    #    elif cal_option == 'GREGORIAN':
    #        nmlgen.set_value('nhours_fcst', value=(datetime.datetime(yyyy+stop_n,mm,dd)-datetime.datetime(yyyy, mm, dd)).hours)  
    #elif 'nmonth' in stop_option:
    #     ddif = (datetime.datetime(yyyy+(stop_n/12), mm+(stop_n%12)+1, dd, hh, mi, ss)-datetime.datetime(yyyy, mm, dd, hh, mi, ss)).days
    #     if cal_option == 'NO_LEAP':
    #        nleap = 0
    #        for i in xrange(yyyy, yyyy+(stop_n/12)+1):
    #            nleap = nleap+calendar.isleap(i)
    #        nmlgen.set_value('nhours_fcst', value=(ddif-nleap)*24)
    #     elif cal_option == 'GREGORIAN':
    #        nmlgen.set_value('nhours_fcst', value=ddif*24)
    #elif 'nday' in stop_option:
    #     #ddif = (datetime.datetime(yyyy+(stop_n/12), mm+(stop_n%12)+1, dd, hh, mi, ss)-datetime.datetime(yyyy, mm, dd, hh, mi, ss)).days

    # modify restart option
    if case.get_value('MEDIATOR_READ_RESTART'):
        nmlgen.set_value('RUN_CONTINUE', value=True)
    else:
        nmlgen.set_value('RUN_CONTINUE', value=False)

    # resolution dependent parameters
    atm_grid = case.get_value("ATM_GRID")
    if (atm_grid == 'C96'):
        nmlgen.set_value('imo', value=384)
        nmlgen.set_value('jmo', value=190)
    elif (atm_grid == 'C384'):
        nmlgen.set_value('imo', value=1536)
        nmlgen.set_value('jmo', value=768)
    else:
        expect(False, "Given resolution " + atm_grid + " currently not supported!")
 
    #----------------------------------------------------
    # Write out model.configure namelist
    #----------------------------------------------------
    model_config_file = os.path.join(confdir, "model_configure")
    nmlgen.write_nuopc_config_file(model_config_file, data_list_path)

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
####################################################################################
def _create_namelist_chgres(case, confdir, infile, nmlgen):
####################################################################################
    """Write out the namelist for this component.

    Most arguments are the same as those for `NamelistGenerator`.
    The `confdir` argument is used to specify the directory  in which output files will be placed.
    """
    #----------------------------------------------------
    # Clear out old data.
    #----------------------------------------------------
    data_list_path = os.path.join(case.get_case_root(), "Buildconf", "fv3gfs.input_data_list")

    #----------------------------------------------------
    # Create config dictionary
    #----------------------------------------------------
    config = {}

    #----------------------------------------------------
    # Initialize namelist defaults
    #----------------------------------------------------
    nmlgen.init_defaults(infile, config)

    #----------------------------------------------------
    # Write out namelist groups
    #----------------------------------------------------
    groups=['config']

    namelist_file = os.path.join(confdir, "config.nml")
    nmlgen.write_output_file(namelist_file, data_list_path, groups=groups, sorted_groups=False)

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
####################################################################################
def _create_namelist_ncep_post(case, confdir, infile, nmlgen):
####################################################################################
    """Write out the namelist for this component.

    Most arguments are the same as those for `NamelistGenerator`.
    The `confdir` argument is used to specify the directory  in which output files will be placed.
    """
    #----------------------------------------------------
    # Clear out old data.
    #----------------------------------------------------
    data_list_path = os.path.join(case.get_case_root(), "Buildconf", "fv3gfs.input_data_list")

    #----------------------------------------------------
    # Create config dictionary
    #----------------------------------------------------
    config = {}

    #----------------------------------------------------
    # Initialize namelist defaults
    #----------------------------------------------------
    nmlgen.init_defaults(infile, config)

    #----------------------------------------------------
    # Write out namelist groups
    #----------------------------------------------------
    groups=['nampgb']

    run_start_date = case.get_value('RUN_STARTDATE').split('-')
    yy = int(run_start_date[0])
    mm = int(run_start_date[1])
    dd = int(run_start_date[2])

    run_start_tod = case.get_value('START_TOD')

    cycle_lst = [12, 24, 36]
    for i in cycle_lst:
        namelist_file = os.path.join(confdir, "itaga.%03d" % (i))
        nmlgen.write_output_file(namelist_file, data_list_path, groups=groups, sorted_groups=False)

        dd_mod = dd
        irest = i
        if i/24 > 0:
            dd_mod = dd+i/24
            irest = i%24

        run_start_tod_new = run_start_tod+irest*3600 
        hh = int(run_start_tod_new//3600)
        mi = int((run_start_tod_new-hh*3600)//60)
        ss = int(run_start_tod_new-hh*3600-mi*60)

        with open(namelist_file, 'r+') as f:
            content = f.read()
            f.seek(0,0)
            f.write(nmlgen.get_value('filename')+"\n")
            f.write(nmlgen.get_value('ioform')+"\n")
            f.write(nmlgen.get_value('outform')+"\n")
            f.write("%04d-%02d-%02d_%02d:%02d:%02d\n"%(yy, mm, dd_mod, hh, mi, ss))
            f.write(nmlgen.get_value('modelname')+"\n")
            f.write(nmlgen.get_value('filenameflux')+"\n")
            f.write(content)

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################

    # Build the component namelist
    if compname != "fv3gfs":
        raise AttributeError
    srcroot = case.get_value("SRCROOT")
    rundir  = case.get_value("RUNDIR")

    # copy/link input files
    prep_input(case)

    # determine the confdir directory
    confdir = os.path.join(caseroot,"Buildconf","fv3gfsconf")
    if not os.path.isdir(confdir):
        os.makedirs(confdir)

    # path for namelist files 
    namelist_xml_dir = os.path.join(srcroot, "src", "model", "FV3", "cime", "cime_config")

    #----------------------------------------------------
    # Namelist generator for chgres
    #----------------------------------------------------

    # set namelist definition file
    definition_file = [os.path.join(namelist_xml_dir, "namelist_definition_fv3.xml")]

    # create the namelist generator object
    nmlgen_chgres = NamelistGenerator(case, definition_file)

    # create namelist_infile using user_nl_file as input
    user_nl_file = os.path.join(caseroot, "user_nl_fv3gfs")
    expect(os.path.isfile(user_nl_file),
           "Missing required user_nl_file %s " %(user_nl_file))
    infile = os.path.join(confdir, "namelist_infile")
    create_namelist_infile(case, user_nl_file, infile)
    namelist_infile = [infile]

    # create namelist config.nml 
    _create_namelist_chgres(case, confdir, namelist_infile, nmlgen_chgres)

    # copy namelist to rundir
    if os.path.isdir(rundir):
        file1 = os.path.join(confdir, "config.nml")
        file2 = os.path.join(rundir, "config.nml")
        logger.debug("CHGRES configuration copy: file1 %s file2 %s " %(file1, file2))
        shutil.copy2(file1, file2)

    #----------------------------------------------------
    # Namelist generator for fv3 (model_configure)
    #----------------------------------------------------

    # create the namelist generator object
    nmlgen_model_configure = NamelistGenerator(case, definition_file)

    # create namelist model_configure
    _create_namelist_model_configure(case, confdir, namelist_infile, nmlgen_model_configure)

    # copy namelist files to rundir
    if os.path.isdir(rundir):
        file1 = os.path.join(confdir, "model_configure")
        file2 = os.path.join(rundir, "model_configure")
        logger.debug("FV3GFS configuration copy: file1 %s file2 %s " %(file1, file2))
        shutil.copy2(file1, file2)

    #----------------------------------------------------
    # Namelist generator for fv3 (input.nml)
    #----------------------------------------------------

    # create the namelist generator object
    nmlgen_input = NamelistGenerator(case, definition_file)

    # create namelist input.nml
    _create_namelist_input(case, confdir, namelist_infile, nmlgen_model_configure, nmlgen_input)

    # copy namelist files to rundir
    if os.path.isdir(rundir):
        file1 = os.path.join(confdir, "atm_in")
        file2 = os.path.join(rundir, "atm_in")
        logger.debug("FV3 namelist copy: file1 %s file2 %s " %(file1, file2))
        shutil.copy2(file1, file2)

    # link file
    logger.info("\tLinking input namelist for FV3GFS")
    if not os.path.exists(rundir):
        expect(False, "Couldn't find run direcory " + rundir)
    run_cmd("ln -sf " + file2 + " " + os.path.join(rundir, "input.nml"))

    #----------------------------------------------------
    # Namelist generator for ncep_post
    #----------------------------------------------------

    # create the namelist generator object
    nmlgen_ncep_post = NamelistGenerator(case, definition_file)

    # remove old configuration files
    for f in os.listdir(confdir):
        if "itaga" in f:
            os.remove(os.path.join(confdir,f))

    # create namelist model_configure
    _create_namelist_ncep_post(case, confdir, namelist_infile, nmlgen_ncep_post)

    # copy namelist to rundir
    if os.path.isdir(rundir):
        for f in os.listdir(confdir):
            if "itaga" in f:
                file1 = os.path.join(confdir, f)
                file2 = os.path.join(rundir, f)
                logger.debug("NCEP_POST configuration copy: file1 %s file2 %s " %(file1, file2))
                shutil.copy2(file1, file2)

    return

###############################################################################
def _main_func():

    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "fv3gfs")

if __name__ == "__main__":
    _main_func()
